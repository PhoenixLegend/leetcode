/*
 * @lc app=leetcode.cn id=136 lang=java
 *
 * [136] 只出现一次的数字
 * 若是能使用比如说hashmap或者是hashset，那么自然相同的数会产生同样的hash值，从而保留单一不重复的元素。
 * 但是如果不使用额外的空间。则需要考虑位操作的思路。
 * 思路：
 * 1.按位与&	如果相对应位都是1，则结果为1，否则为0
 * 2.按位或|	如果相对应位都是0，则结果为0，否则为1
 * 3.按位异或^	如果相对应位值相同，则结果为0，否则为1 异或运算满足交换律和结合律
 * 4.按位取反~	按位取反运算符翻转操作数的每一位，即0变成1，1变成0
 * 5.左移 <<	按位左移运算符。左操作数按位左移右操作数指定的位数
 * 6.右移 >>	按位右移运算符。左操作数按位右移右操作数指定的位数	
 * 
 * 由条件3可得知，如果两数相同，则异或为0，而0和任何数异或都为本身。
 * 那这个题就变成了整个数据全部异或。
 * 由于成双成对的cp在一起自动“隐藏”，那么剩下的那个，就是原形毕露的的“单身狗”。
 * 史称“单身狗·原型毕露计划”
 */

// @lc code=start
class Solution {
    public int singleNumber(int[] nums) {
        int rs = nums[0];
        for (int i = 1; i < nums.length; i++) {
            rs = rs ^ nums[i];
        }
        return rs;
    }
}
// @lc code=end
